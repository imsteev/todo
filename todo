#!/usr/local/bin/python3
import argparse
import datetime
import json
import prettytable
import time
import webbrowser

import manager


def TodoItem(text, link=None):
    return {
        'text': text,
        'updated_at': now(),
        'complete': False,
        'link': link
    }


class Todo(object):
    def __init__(self, source):
        self.todo = self.load(source)
        self.source = source

    def load(self, source):
        with open(source, 'r') as f:
            ret = json.load(f)
            if not isinstance(ret, dict):
                raise ValueError('todo currently only supports objects. are you using the right file?')

        if not 'items' in ret:
            ret['items'] = []

        return ret

    def save(self):
        self.todo['last_updated'] = now()
        self.validate()
        with open(self.source, 'w') as f:
            json.dump(self.todo, f)

    def validate(self):
        """
            {
                'last_updated': <str>,
                'items': [
                    {
                        'text': <str>,
                        'updated_at': <str>,
                        'complete': <bool>
                    }
                    ...
                ]
            }
        """
        assert isinstance(self.todo, dict)
        assert isinstance(self.todo.get('last_updated'), str)
        assert isinstance(self.todo.get('items'), list)
        for item in self.todo['items']:
            assert isinstance(item, dict)
            assert isinstance(item.get('text'), str)
            assert isinstance(item.get('updated_at'), str)
            assert isinstance(item.get('complete'), bool)

    def add(self, text):
        self.todo['items'].append(TodoItem(text))

    def update(self, i, **kwargs):
        if i < 0 or i >= len(self.todo['items']):
            raise ValueError
        kwargs.update({'updated_at': now()})
        self.todo['items'][i].update(kwargs)

    def delete(self, start, end=None):
        """ Deletes items in range [start, end). Note inclusive start, exclusive end. """
        end = end or start + 1
        if not (0 <= start < end):
            raise Exception('Cannot delete items in range [{0}, {1})'.format(start, end))
        del self.todo['items'][start:end]

    def get(self, i):
        if i < 0 or i >= len(self.todo['items']):
            raise ValueError
        return self.todo['items'][i]

    def show(self):
        """
        1. item text
        2. item text
        ..
        """
        pt = prettytable.PrettyTable(field_names=['#', 'Text', 'Link'])
        pt.align['Link'] = 'l'
        pt.align['Text'] = 'l'

        for i, item in enumerate(self.todo['items']):
            text = item['text']
            if item['complete']:
                text = strikethrough(text)

            pt.add_row([i + 1, text, item['link'] or "-"])

        print(pt)

        if 'last_updated' in self.todo:
            print("Last updated: {}".format(self.todo['last_updated']))


def strikethrough(text):
    result = ''
    for c in str(text):
        result = result + c + '\u0336'
    return result


def now():
    return datetime.datetime.strftime(datetime.datetime.now(), "%m-%d-%Y %I:%M %p")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    # actions that require saving current state of Todo.todo
    parser.add_argument("-a", "--add", nargs=1, metavar=('text'), action="store", help="add text to todo list")
    parser.add_argument("-u", "--update", nargs=2, metavar=('index', 'text'), action="store", help="update todo item at 1-indexed position i")
    parser.add_argument("-d", "--delete", nargs="*", help="delete text in todo list by 1-indexed position")
    parser.add_argument("--clear", action="store_true", help="clear entire todo list")
    parser.add_argument("-l", "--link", nargs="*", action="store", help="reference a link for a todo item")
    parser.add_argument("-t", "--toggle-complete", type=int, help="toggle item as complete or not")

    # actions that don't require saving
    parser.add_argument("-g", "--goto", nargs=1, metavar=('index'), action="store", help="open link in browser")
    parser.add_argument("--push", action="store_true", help="push todo to external storage")
    parser.add_argument("--pull", action="store_true", help="pull todo from external storage")
    parser.add_argument("--sync", action="store_true", help="sync todo from external storage")

    args = parser.parse_args()

    todo = Todo(manager.TODO_FILE)

    if args.add:
        # todo -a "get groceries" -l https://example.com/grocery-list
        todo.add(args.add[0])
        if args.link:
            index = len(todo.todo['items']) - 1
            link = args.link[0]
            todo.update(index, link=link)
    elif args.delete:
        end = None
        if ".." in args.delete[0]:
            # todo -d 1..5
            start, end = args.delete[0].split("..")
            start = int(start) - 1
            end = int(end) - 1
        else:
            # todo -d 4
            start = int(args.delete[0]) - 1
        todo.delete(start, end)
    elif args.update:
        todo.update(int(args.update[0]) - 1, text=args.update[1])
    elif args.link:
        # todo -l 1 https://example.com
        index = int(args.link[0]) - 1
        link = args.link[1]
        todo.update(index, link=link)
    elif args.clear:
        todo.delete(0, len(todo.todo['items']))
    elif args.goto:
        todo_item = todo.get(int(args.goto[0]) - 1)
        item_link = todo_item.get('link')
        if item_link:
            webbrowser.open_new(item_link)
    elif args.toggle_complete:
        index = int(args.toggle_complete) - 1
        todo_item = todo.get(index)
        todo.update(index, complete=not todo_item['complete'])
    elif args.push:
        todo.validate()
        manager.push(todo.source)
    elif args.pull:
        manager.pull()
        todo = Todo(manager.TODO_FILE)
        todo.show()
    elif args.sync:
        manager.sync()
    else:
        todo.show()

    need_to_save = any([
        args.add, args.update, args.delete, args.clear, args.link,
        args.toggle_complete
    ])

    if need_to_save:
        todo.save()
